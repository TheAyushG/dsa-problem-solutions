//detect cycle in a directed graph using DFS

class Solution { 
  public: 
    // Helper function to check cycle in directed graph 
    bool isCyclicUtil(vector<int> adj[], int u, vector<bool>& visited, vector<bool>& inRecursion) { 
        visited[u] = true; 
        inRecursion[u] = true; 

        for(int v : adj[u]) { 
            // If v is not visited, recurse 
            if(!visited[v] && isCyclicUtil(adj, v, visited, inRecursion)) 
                return true; 

            // If v is in current recursion stack â†’ cycle found 
            else if(inRecursion[v]) 
                return true; 
        } 

        inRecursion[u] = false; // backtrack 
        return false; 
    } 

    // Main function 
    bool isCyclic(int V, vector<int> adj[]) { 
        vector<bool> visited(V, false); 
        vector<bool> inRecursion(V, false); 

        // Check for cycle in every component 
        for(int i = 0; i < V; i++) { 
            if(!visited[i]) { 
                if(isCyclicUtil(adj, i, visited, inRecursion)) 
                    return true; 
            } 
        } 
        return false; 
    } 
};


//expnation of the code
bool isCyclicUtil(vector<int> adj[], int u, vector<bool>& visited, vector<bool>& inRecursion) {
        
    visited[u] = true;        // (1)
    inRecursion[u] = true;    // (2)
        
    for(int v : adj[u]) {     // (3)
        if(!visited[v] && isCyclicUtil(adj, v, visited, inRecursion))   // (4)
            return true;      // (5)
            
        else if(inRecursion[v])   // (6)
            return true;      // (7)
    }
        
    inRecursion[u] = false;   // (8)
    return false;             // (9)
}



ðŸ”¹ Example Graph
Letâ€™s take a directed graph with a cycle:

0 â†’ 1
1 â†’ 2
2 â†’ 0   (cycle here)

Adjacency List:
0: [1]
1: [2]
2: [0]

ðŸ”¹ Step-by-Step Execution (Dry Run)
//step = 1
Call: isCyclicUtil(adj, 0, visited, inRecursion)
Line (1): visited[0] = true;
â†’ Mark 0 as visited.
visited = [true, false, false]

Line (2): inRecursion[0] = true;
â†’ Mark 0 as part of the current recursion path.
inRecursion = [true, false, false]

Line (3): Loop over neighbors of 0.
â†’ Neighbor = 1.

Neighbor 1 (from 0 â†’ 1)
Line (4): !visited[1] is true, so call isCyclicUtil(adj, 1, ...).



//step = 2
Call: isCyclicUtil(adj, 1, visited, inRecursion)
Line (1): visited[1] = true;
visited = [true, true, false]

Line (2): inRecursion[1] = true;
inRecursion = [true, true, false]

Line (3): Loop over neighbors of 1.
â†’ Neighbor = 2.

Neighbor 2 (from 1 â†’ 2)

Line (4): !visited[2] is true, so call isCyclicUtil(adj, 2, ...).



//step = 3
Call: isCyclicUtil(adj, 2, visited, inRecursion)

Line (1): visited[2] = true;
visited = [true, true, true]

Line (2): inRecursion[2] = true;
inRecursion = [true, true, true]

Line (3): Loop over neighbors of 2.
â†’ Neighbor = 0.

Neighbor 0 (from 2 â†’ 0)

Line (4): !visited[0] is false (since 0 is already visited). Skip this.

Line (6): else if(inRecursion[0]) â†’ true (because 0 is still in recursion stack).

ðŸ‘‰ Cycle detected! Return true.
ðŸ”¹ Flow of Return
From 2 â†’ 0, return true.
Bubble up to 1, return true.
Bubble up to 0, return true.
Final answer: Cycle exists.
