//438. Find All Anagrams in a String

//Method Name: Sliding Window with Frequency Count
//Time Complexity: O(n)
//Space Complexity: O(1)
// frequency array is used to solve this question

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int>result;

        if(s.size() < p.size())
        return result;

        vector<int> freqP(26,0), freqWindow(26,0);
        for(int i=0; i<p.size(); i++){
            char ch = p[i];
            freqP[ch - 'a']++;
        }

        int k = p.size();
        for(int i=0; i<s.size(); i++){
            freqWindow[s[i] - 'a']++;

            if(i>=k){
                freqWindow[s[i-k] - 'a']--;
            }

            if(i >= k-1 && freqWindow == freqP){
                result.push_back(i-k+1);
            }
        }
        return result;
    }
};



//using unordered hash map

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        if (s.size() < p.size()) return result;

        unordered_map<char, int> mapP, mapWin;
        int k = p.size();

        for (char c : p) {
            mapP[c]++;
        }

        for (int i = 0; i < k; i++) {
            mapWin[s[i]]++;
        }

        if (mapWin == mapP) {
            result.push_back(0);
        }

        
        for (int i = k; i < s.size(); i++) {
            char newChar = s[i];
            char oldChar = s[i - k];

            mapWin[newChar]++;

            mapWin[oldChar]--;
            if (mapWin[oldChar] == 0) {
                mapWin.erase(oldChar); 
            }

            if (mapWin == mapP) {
                result.push_back(i - k + 1);
            }
        }

        return result;
    }
};
