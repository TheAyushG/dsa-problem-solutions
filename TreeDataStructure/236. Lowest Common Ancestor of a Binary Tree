//236. Lowest Common Ancestor of a Binary Tree

//optimal solution
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL)
        return NULL;

        if(root == p || root == q)
        return root;

        TreeNode* leftN = lowestCommonAncestor(root->left, p, q);
        TreeNode* rightN = lowestCommonAncestor(root->right, p, q);

        if(leftN != NULL && rightN != NULL)
        return root;

        if(leftN != NULL)
        return leftN;

        return rightN;
    }
};





//not a optimal solution
// class Solution {
// public:

//     bool findPath(TreeNode* root, TreeNode* target, vector<TreeNode*>& path){

//         if(root == NULL){
//             return false;
//         }

//         path.push_back(root);

//         if(root == target)
//         return true;
       
//         if (findPath(root->left, target, path) || findPath(root->right, target, path))
//         return true;

//         path.pop_back();
//         return false;

//     }

//     TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
//         vector<TreeNode*> path1,path2;

//         findPath(root, p, path1);
//         findPath(root, q, path2);
        
//         int i=0;
//         while(i < path1.size() && i < path2.size() && path1[i] == path2[i]){
//             i++;
//         }

//         return path1[i-1];
//     }
// };
