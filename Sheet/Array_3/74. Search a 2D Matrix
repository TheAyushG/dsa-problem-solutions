**optimal solution** |
Time - O(log n*m);   |
Space - O(1);        |
----------------------
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int rows = matrix.size();
        int cols = matrix[0].size();

        int low = 0;
        int high = rows * cols - 1;

        while(low <= high){

            int mid = low +(high - low) / 2;

            int r = mid / cols;
            int c = mid % cols;

            if(matrix[r][c] == target){
                return true;
            }

            else if(matrix[r][c] < target){
               low = mid+1;
            }

            else{
               high = mid-1;
            }
        }

        return false;
    }
};

---------------------------------------------------------------------------------------------------------------

//not optimal but littil bit optimal
//using binary Search, in every row
//Time - O(n) + (log m) 
//because we just applying binary search in each row and iterate every row so      // for row it iterate on each number so O(b), but row length is m that's why m lenght time compexity is (log m)
//Space - O(1);



class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        
        
        int row = matrix.size();
        int col = matrix[0].size();

        for(int i=0; i<row; i++){
            if(target >= matrix[i][0] && target <=  matrix[i][col-1]){

                int low = 0;
                int high = col-1;

                while(low <= high){
                    int mid = low + (high - low)/2;
                    if(matrix[i][mid] == target){
                        return true;
                    }

                    else if(matrix[i][mid] < target){
                        low = mid+1;
                    }

                    else{
                        high = mid-1;
                    }
                }
            }
        }
        return false;
    }
};
